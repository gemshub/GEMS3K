<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>

  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

  
  <meta name="GENERATOR" content="Mozilla/4.72 [en]C-BLUEWIN-CH20  (Win98; I) [Netscape]"><title>How to couple codes with GEMS3K at simple level</title></head><body style="background-image: url(bgimg-gray.jpg);">
<h1><img src="gems1.png" align="left" height="48" width="48">
GEMS3K Solver of GeoChemical Equilibria<br>
</h1>

<p> </p>

<h2>Coupling with GEMS3K at Simple TNode Level</h2>

<hr size="2" width="100%">
<h3>Contents</h3>

<p><a href="#TAG_INTRO">1. Introduction</a></p>

<p><a href="#TAG_DISKONLY">2. Data exchange using disk files only</a></p>

<p><a href="#TAG_MEMEXCHANGE">3. Data exchange in computer memory</a> </p>

<p><a href="#TAG_FAQ">4. Frequently asked questions</a></p>

<br>

<hr size="2" width="100%">
<h3><a name="TAG_INTRO"></a>1. Introduction<br>
</h3>

<p class="MsoNormal" style="margin-bottom: 6pt; text-align: left;">The&nbsp;
<tt>main.cpp</tt>&nbsp;
file
in "<tt>standalone/gemcalc/</tt>" folder
shows how to perform a batch calculation of chemical equilibria using
the input
data given in DCH, IPM and one or more DBR files; the results are
written into
DBR files or (optionally) into a dump text output file.&nbsp; </p>

<p class="MsoNormal" style="margin-bottom: 6pt; text-align: left;"><tt>M</tt><tt>ain.cpp</tt>
and <tt>main.h</tt>&nbsp; files
in&nbsp; "<tt>standalone/node-gem</tt>/" folder&nbsp;
shows how the coupling with a "transport part" having
several nodes can be arranged, where the chemical data and parameters
are kept
in dynamic arrays and exchanged with the GEMS3K in computer memory.
The modification to a &#8220;real&#8221; mass transport method is
straightforward, although this would make the example program too
complicated.&nbsp; </p>

In
these examples,
some options are shown that may significantly improve performance and
accuracy
of GEMS3K.&nbsp; <br>

<p>As the mass
transport part has no direct access to internal IPM work data, the
calculations
of equilibria occur as if they were done in &#8220;real&#8221; amounts consistent
with the
current size of the node. The use of internal re-scaling mechanism
leads, in general,
to a much
better convergence of GEMS3K and to higher precision of its results.</p>

<p>The current
chemical speciation (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
vector, amounts
of Dependent Components) is usually the output from GEM IPM
runs (can also be used as input initial approximation in SIA mode). The
ultimate
input of GEMS3K is the bulk chemical composition vector (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>),
temperature and
pressure. So, at time steps, the mass transport part should change the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span> vector
and,
maybe, <i>T</i>
and/or <i>P</i> in every node, and
this must be sufficient.&nbsp; &nbsp;&nbsp;
</p>

<p>However, in many
existing advection/diffusion transport codes (e.g.
OpenGeoSys),&nbsp;not
the total amounts of independent components, but rather the amounts of
aqueous
species are moved between nodes. Conversely, after the mass transport
step,
only the speciation vector <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
is changed in
each node, and an additional step would be needed to compute a
corrected <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
vector
(i.e. elemental bulk composition) in the mass transport part, which
will be the
GEM input for computing the new speciation <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>.
&nbsp;In
turn, this would require access to several data objects (such as the A
stoichiometry
matrix) in the <tt>DATACH</tt> structure.<span style="font-family: Helvetica,Arial,sans-serif;"></span></p>

<p><span style="font-family: Helvetica,Arial,sans-serif;"></span></p>

<p>In order to make this
unnecessary, the TNode class provides
a variant of <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">GEM_from_MT()</span>
function call
where the re-calculation of input (changed) <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
speciation into
new <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
bulk composition
vector is performed inside of GEMS3K before the internal mass scaling
and calculation
of new equilibrium state. Actually, total amounts of Independent
Components are
calculated from stoichiometries of Dependent Components (as provided in
the A matrix) and their
amounts (in the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
vector passed
through the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_xDC</span>
parameter), and
then added to the amounts given in the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span> vector
(passed through <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_bIC</span>
parameter).
Here,
two cases are possible. One case is when the mass transport step puts
in the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_xDC</span>
parameter the differences
between the new and the old speciation in the node chemical system. In
this
case, the old <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_bIC</span>
content (e.g.
unchanged since the last GEM calculation for this node) must be
provided and it will be automatically corrected.&nbsp; Another (more
usual) case
is when the mass-transport part delivers in <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_xDC</span> the
complete new
speciation (absolute
amounts) after the transport time step. In this case, the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_bIC</span>
vector must be
filled with zeros because its new content will be completely retrieved
from the
p_<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
vector.
</p>

<p>Concerning the &#8220;Smart
Initial Approximation&#8221; (SIA) mode,
the TNode class contains a parameter in <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">GEM_run()</span>
call and yet another
variant of <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">GEM_from_MT()</span>
function that
control what initial approximation of GEM speciation vector will
be used. Basically, regardless of what the mass transport part does,
the GEMS3K can use previous contents of
speciation
and activity coefficients vectors in MULTI structure as an initial
approximation for the next GEM calculation &#8211; even if the bulk
composition b or
temperature T have had changed. This mode is set by the default <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">uPrimalSol</span>
parameter value
(<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">false</span>).
</p>

<p>Another, more
efficient variant (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">uPrimalSol = true</span>)
can be used when
the mass transport part directly changes the chemical speciation in the
node while
taking care of material balance, and the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span> input
vector must be
restored anyway from
the new <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
vector contents
(provided together with activity coefficients stored for this
node at previous time step). In this case, the SIA mode is very
efficient because
the mass balance is already ensured, and this may lead to a very
serious reduction
of the number of GEM iterations and total computing time. &nbsp;Note
that this
SIA mode works only when the
DATACH structure contains a full list of Dependent Components used in
GEM calculations.
</p>

<p>The
TNode
class provides dozens of access methods to single items of chemical
data. Usage
of these public methods is strongly preferred over direct access to
fields of
the DATABR and DATACH memory structures. The
provided methods use either DATABR or DATACH indexation. </p>

In DBR files
and DATABR structure, the results for volumes, masses and bulk
compositions are
only provided for multi-component phases, because for pure phases they
can be
easily retrieved. Nevertheless, TNode public functions such as <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">Ph_Volume(),
Ph_Mass(),
Ph_BC()</span> and
<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">Ph_SatInd()</span>
work both for
multi- and single-component phases. This is done in order to make
access to such data from the side of mass-transport part of the program
as simple
as possible.<br>

<br>

<hr size="2" width="100%">
<h3><a name="TAG_DISKONLY"></a>2. Data exchange using disk files only</h3>

<p><span style="font-family: Helvetica,Arial,sans-serif;">Programming
example fragment (see full example in </span><big><span style="font-family: monospace;">"<small>standalone/gemcalc/main.cpp</small></span></big><span style="font-family: Helvetica,Arial,sans-serif;">"): </span></p>

<span style="font-family: monospace;"></span><span style="font-family: monospace;"></span>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;"><tt>#include "node.h"</tt><tt><br>
      </tt><tt> </tt><tt>&nbsp;&nbsp; </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // Creates TNode structure instance
accessible trough the "node" pointer</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; TNode* node&nbsp; = new TNode();</tt><tt><br>
      </tt><tt>&nbsp; </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // (1) Initialization of GEMS3K internal
data by reading&nbsp; files</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; whose names are
given in the input_system_file_list_name</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; if( node-&gt;GEM_init(
input_system_file_list_name ) )</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; {</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error occured during
reading the files</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; }</tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // Getting direct access to work node
DATABR structure which exchanges the</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // data with GEM IPM2 (already filled out
by reading the DBR input file)</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; DATABR* dBR = node-&gt;pCNode(); </tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // Asking GEM to run with automatic initial
approximation </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; dBR-&gt;NodeStatusCH = NEED_GEM_AIA;</tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // (2) re-calculating equilibrium by
calling GEMS3K, getting the status back</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; int NodeStatusCH = node-&gt;GEM_run(&nbsp;
false );</tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; if( NodeStatusCH == OK_GEM_AIA ||
NodeStatusCH == OK_GEM_SIA&nbsp; )</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // (3) Writing results
in default DBR file</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_write_dbr( NULL, false, true );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_print_ipm( NULL );&nbsp;&nbsp; // possible debugging
printout</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; }</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; else {</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4) possible return
status analysis, error message</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_print_ipm( NULL );&nbsp;&nbsp; // possible debugging
printout</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 5; // GEM
IPM did not converge properly&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt><tt><br>
      </tt><tt><br>
&nbsp;&nbsp; // Here a
possible loop
on input recipes begins</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // (5) Reading the next DBR file with
different input composition or temperature</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_read_dbr( NextRecipeFileName );</tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Asking GEM
IPM2 to run (faster) with smart initial approximation </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dBR-&gt;NodeStatusCH = NEED_GEM_SIA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NodeStatusCH
= node-&gt;GEM_run( false );</tt><tt><br>
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(
NodeStatusCH == OK_GEM_AIA || NodeStatusCH == OK_GEM_SIA&nbsp; )</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp; sprintf(NextRecipeOutFileName , "%s.out",
NextRecipeFileName );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp; node-&gt;GEM_write_dbr( NextRecipeOutFileName, false, true );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sprintf(NextRecipeOutFileName , "%s.Dump.out", NextRecipeFileName );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_print_ipm( NextRecipeOutFileName );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// error message, debugging printout</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(NextRecipeOutFileName ,
"%s.Dump.out", NextRecipeFileName );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_print_ipm( NextRecipeOutFileName );</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 5; // GEM IPM did not converge properly</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; // end of
possible loop
on input recipes<br>
&nbsp;</tt><tt><br>
      </tt><tt> </tt><tt>&nbsp;&nbsp; delete node;</tt><br style="font-family: monospace;">
      <span style="font-family: monospace;"><br>
      </span></td>
    </tr>
  </tbody>
</table>

<span style="font-family: monospace;"></span><br>

<br>

<hr size="2" width="100%">
<h3><a name="TAG_MEMEXCHANGE"></a>3. Data exchange in computer memory </h3>

<p>This case is
typical for coupling GEMS3K with an existing reactive
mass transport code that has its own data structure for keeping
chemical information (e.g. speciation, bulk composition of the system)
for each node. As in the previous example, it uses one work instance of
the <span style="font-family: monospace;">DATABR</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>memory
structure as data bridge for the exchange with internal GEM IPM data
structures. <br>
</p>

<p>
This example code consists of two C++ files: "<tt>main.h</tt>" and "<tt>main.cpp</tt>",
located in the "<tt>standalone/node-gem/</tt>" folder. The former file
contains a definition of<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
</span>class representing a typical dynamic memory structure used for
keeping current chemical composition and speciation for all nodes
involved in the reactive mass transport system. The latter file
contains
an implementation of some public methods of<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>class, as
well as the main function which shows the sequence of calls to<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TNode</span><span style="font-family: Helvetica,Arial,sans-serif;">
</span>class functions, necessary to perform coupled reactive transport
calculations based on the "operator splitting" approach. <span style="font-family: Helvetica,Arial,sans-serif;"><br>
</span></p>

<p>This example
is designed to help learning how to couple the existing transport code
with GEMS3K in a simple way, and it does not contain a 'real' transport
code which would make the example more difficult to observe. The
transport model itself is located in the <tt>TMyTransport::OneTimeStepRun()</tt>
function and can be improved there to any desired extent. <br>
</p>

<p><span style="font-family: Helvetica,Arial,sans-serif;"></span></p>

<span style="font-family: Helvetica,Arial,sans-serif;">
</span>
<p>Here is a code snippet with the<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>class
definition (see complete code in
<span style="font-family: monospace;">standalone/node-gem/main.h</span>):
<span style="font-family: monospace;"></span></p>

<span style="font-family: monospace;">
</span><span style="font-family: Helvetica,Arial,sans-serif;"></span>
<table style="text-align: left; width: 100%; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;">#include "node.h"<br>
      <br>
class TMyTransport<br>
{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp; long int nNodes,&nbsp; // Number of mass transport
nodes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nTimes,&nbsp;&nbsp; // Number of time steps<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nIC,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical independent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nDC,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical dependent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nPH,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical phases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nPS;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical
phases-solutions<br>
      <br>
&nbsp;&nbsp;&nbsp; long int *aNodeHandle,&nbsp;&nbsp;&nbsp;&nbsp; //
Node identification handles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aNodeStatusCH,&nbsp;&nbsp; // Node status codes (changed after GEM
calculation)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aIterDone;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of GEM IPM
iterations performed for each node<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;&nbsp; at the last time step<br>
      <br>
&nbsp;&nbsp;&nbsp; double *aT,&nbsp;&nbsp;&nbsp;&nbsp; // Array of node
temperatures T, Kelvin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aP,&nbsp;&nbsp;&nbsp;&nbsp; // Array of node pressures P, Pa<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aVs,&nbsp;&nbsp;&nbsp; // Array of node volume V of reactive
subsystem, m3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aMs,&nbsp;&nbsp;&nbsp; // Array of node mass of reactive subsystem, kg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aGs,&nbsp;&nbsp;&nbsp; // Array of node total Gibbs energy of reactive
subsystems, J<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aHs,&nbsp;&nbsp;&nbsp; // Array of node total enthalpy of reactive
subsystems, J (reserved)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aIC,&nbsp;&nbsp;&nbsp; // Array of node effective aqueous ionic
strengths, molal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*apH,&nbsp;&nbsp;&nbsp; // Array of node pH of aqueous solutions<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*ape,&nbsp;&nbsp;&nbsp; // Array of node pe of aqueous solutions<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aEh;&nbsp;&nbsp;&nbsp; // Array of node Eh of aqueous solution, V<br>
      <br>
&nbsp;&nbsp;&nbsp; double **axDC,&nbsp; // Array of node mole amounts
of dependent components (speciation)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**agam,&nbsp; // Array of node activity coefficients of dependent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**axPH,&nbsp; // Array of node total mole amounts of all reactive phases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**aaPH,&nbsp; // Array of node specific surface areas of phases, m2/kg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**avPS,&nbsp; // Array of node total volumes of multicomponent phases,
m3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**amPS,&nbsp; // Array of node total masses of multicomponent phases,kg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**abPS,&nbsp; // Array of node bulk compositions of multicomponent
phases, moles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**axPA,&nbsp; // Array of node amount of carrier in asymmetric phases,
moles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**aaPh,&nbsp; // Array of node surface areas of phases, m2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**adul,&nbsp; // Array of node upper restrictions to amounts of
dependent components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**adll,&nbsp; // Array of node lower restrictions to amounts of
dependent components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**abIC,&nbsp; // Array of node bulk mole amounts of independent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**arMB,&nbsp; // Array of node mole balance residuals for independent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**auIC,&nbsp; // Array of node chemical potentials of independent
components (norm.)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**abSP;&nbsp; // Array for bulk composition of solid part of
equilibrated sub-system<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMyTransport(&nbsp;&nbsp; //
Constructor (dynamic memory allocation)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
p_nNod,&nbsp;&nbsp;&nbsp; // Number of nodes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
p_nTim,&nbsp;&nbsp;&nbsp; // Number of time steps<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
p_nIC,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical independent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
p_nDC,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical dependent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
p_nPH,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical phases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
p_nPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical phases -
solutions<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~TMyTransport();&nbsp; //
Destructor of dynamic memory<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
OneTimeStepRun(&nbsp;&nbsp; // Placeholder function for one transport
time step<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
*stoich,&nbsp;&nbsp;&nbsp;&nbsp; // Stoichiometry coefficients<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
*ICndx,&nbsp;&nbsp;&nbsp; // Indexes of mobile independent components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int
nICndx&nbsp;&nbsp;&nbsp;&nbsp; // Number of mobile independent
components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
};<br>
      <br>
      </td>
    </tr>
  </tbody>
</table>

<span style="font-family: Helvetica,Arial,sans-serif;"><br>
</span>
<p>All data and
methods in this class are declared as 'public' to make the example
program more straightforward. The three functions belonging to<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>class are
implemented in the<span style="font-family: Helvetica,Arial,sans-serif;"></span>
"<span style="font-family: monospace;">standalone/node-gem/main.cpp</span>"
file as follows:</p>

<p><span style="font-family: Helvetica,Arial,sans-serif;"></span></p>

<span style="font-family: Helvetica,Arial,sans-serif;"></span>
<table style="text-align: left; width: 100%; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;">#include "node.h"<br>
#include "main.h"<br>
      <br>
TMyTransport::TMyTransport( long int p_nNod, long int p_nTim, long int
p_nIC, long int p_nDC,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
long int p_nPH, long int p_nPS )<br>
{<br>
      <br>
&nbsp;&nbsp;&nbsp; nNodes = p_nNod;<br>
&nbsp;&nbsp;&nbsp; nTimes = p_nTim;<br>
&nbsp;&nbsp;&nbsp; nIC = p_nIC;<br>
&nbsp;&nbsp;&nbsp; nDC = p_nDC;<br>
&nbsp;&nbsp;&nbsp; nPH = p_nPH;<br>
&nbsp;&nbsp;&nbsp; nPS = p_nPS;<br>
      <br>
&nbsp;&nbsp;&nbsp; aNodeHandle = new long int [nNodes];<br>
&nbsp;&nbsp;&nbsp; aNodeStatusCH = new long int [nNodes];<br>
&nbsp;&nbsp;&nbsp; aIterDone = new long int [nNodes];<br>
      <br>
&nbsp;&nbsp;&nbsp; aT = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aP = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aVs = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aMs = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aGs = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aHs = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aIC = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; apH = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; ape = new double [nNodes];<br>
&nbsp;&nbsp;&nbsp; aEh = new double [nNodes];<br>
      <br>
&nbsp;&nbsp;&nbsp; axDC = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; agam = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; axPH = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; aaPH = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; avPS = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; amPS = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; abPS = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; axPA = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; aaPh = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; adul = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; adll = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; abIC = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; arMB = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; auIC = new double *[nNodes];<br>
&nbsp;&nbsp;&nbsp; abSP = new double *[nNodes];<br>
      <br>
&nbsp;&nbsp;&nbsp; for (long int in=0; in&lt;nNodes; in++)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abIC[in] = new double
[nIC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arMB[in] = new double
[nIC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auIC[in] = new double
[nIC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; axDC[in] = new double
[nDC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; agam[in] = new double
[nDC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adul[in] = new double
[nDC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adll[in] = new double
[nDC];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaPH[in] = new double
[nPH];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; axPH[in] = new double
[nPH];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; avPS[in] = new double
[nPS];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amPS[in] = new double
[nPS];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; axPA[in] = new double
[nPS];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaPh[in] = new double
[nPH];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abPS[in] = new double
[nIC*nPS];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abSP[in] = new double
[nIC];<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
}<br>
      <br>
TMyTransport::~TMyTransport()<br>
{<br>
&nbsp; &nbsp; // Deleting chemical data arrays for nodes<br>
&nbsp;&nbsp;&nbsp; for (long int in=0; in&lt;nNodes; in++)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]abIC[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]arMB[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]auIC[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]axDC[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]agam[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]adul[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]adll[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]aaPH[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]axPH[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]avPS[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]amPS[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]axPA[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]aaPh[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]abPS[in];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]abSP[in];<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; delete[]axDC;<br>
&nbsp;&nbsp;&nbsp; delete[]agam;<br>
&nbsp;&nbsp;&nbsp; delete[]axPH;<br>
&nbsp;&nbsp;&nbsp; delete[]aaPH;<br>
&nbsp;&nbsp;&nbsp; delete[]avPS;<br>
&nbsp;&nbsp;&nbsp; delete[]amPS;<br>
&nbsp;&nbsp;&nbsp; delete[]abPS;<br>
&nbsp;&nbsp;&nbsp; delete[]axPA;<br>
&nbsp;&nbsp;&nbsp; delete[]aaPh;<br>
&nbsp;&nbsp;&nbsp; delete[]adul;<br>
&nbsp;&nbsp;&nbsp; delete[]adll;<br>
&nbsp;&nbsp;&nbsp; delete[]abIC;<br>
&nbsp;&nbsp;&nbsp; delete[]arMB;<br>
&nbsp;&nbsp;&nbsp; delete[]auIC;<br>
&nbsp;&nbsp;&nbsp; delete[]abSP;<br>
      <br>
&nbsp;&nbsp;&nbsp; delete[]aNodeHandle;<br>
&nbsp;&nbsp;&nbsp; delete[]aNodeStatusCH;<br>
&nbsp;&nbsp;&nbsp; delete[]aIterDone;<br>
&nbsp;&nbsp;&nbsp; delete[]aT;<br>
&nbsp;&nbsp;&nbsp; delete[]aP;<br>
&nbsp;&nbsp;&nbsp; delete[]aVs;<br>
&nbsp;&nbsp;&nbsp; delete[]aMs;<br>
&nbsp;&nbsp;&nbsp; delete[]aGs;<br>
&nbsp;&nbsp;&nbsp; delete[]aHs;<br>
&nbsp;&nbsp;&nbsp; delete[]aIC;<br>
&nbsp;&nbsp;&nbsp; delete[]apH;<br>
&nbsp;&nbsp;&nbsp; delete[]ape;<br>
&nbsp;&nbsp;&nbsp; delete[]aEh;<br>
}<br>
      <br>
// A very simple example of transport algorithm<br>
void TMyTransport::OneTimeStepRun( double *stoicf, long int *ICndx,
long int nICndx )<br>
{<br>
&nbsp;&nbsp;&nbsp; double parcel[nICndx];<br>
&nbsp;&nbsp;&nbsp; long int in;<br>
&nbsp;&nbsp;&nbsp; for(&nbsp; in=1; in&lt; nNodes; in++ )<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; // some operators that change in some nodes some
amounts of some migrating<br>
&nbsp;&nbsp;&nbsp; // chemical species (axDC array or&nbsp; some
amounts of migrating chemical<br>
&nbsp;&nbsp;&nbsp; // elements in abIC array), possibly using data from
other arrays in such<br>
&nbsp;&nbsp;&nbsp; // a way that the mass conservation within the whole
array of nodes is retained<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;nICndx;
i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
parcel[i] = 0.01* stoicf[i]*abIC[in-1][ICndx[i]];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
abIC[in][ICndx[i]] += parcel[i];<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( in &gt; 1 )<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
abIC[in-1][ICndx[i]] -= parcel[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; // The above example loop implements a zero-order
flux of MgCl2 in one direction.<br>
&nbsp;&nbsp;&nbsp; // Real advective/diffusive transport models are
much more complex, but essentially<br>
&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; do similar things<br>
&nbsp;&nbsp;&nbsp; }<br>
}<br>
      <br>
      </td>
    </tr>
  </tbody>
</table>

<span style="font-family: Helvetica,Arial,sans-serif;"><br>
</span>The last function<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">OneTimeStepRun()</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>is
not an implementation of a 'real' mass transport integration time step,
but otherwise, it does the same, i.e. modifies bulk chemical
composition of nodes by shifting some amounts of elements from one node
to another, using the zeroth node as an infinite source of constant
composition - MgCl<sub>2</sub> solution. And it is called from the same
place of the example coupled code where the code performing the
transport time step should be called from (see below). <span style="font-family: Helvetica,Arial,sans-serif;"><br>
&nbsp;&nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;"> &nbsp; </span><br>

The first part of <tt>main.cpp</tt> (see full example in
<span style="font-family: monospace;">"standalone/node-gem/main.cpp</span>")
creates the <tt>TNode</tt> class instance and initializes it by
reading three GEMS3K input files (provided in<span style="font-family: Helvetica,Arial,sans-serif;"> <tt>"standalone</tt></span><span style="font-family: monospace;">/node-gem-build/tp_test/</span>"),
which it extracts from the file list passed through the first command
line argument. Then an instance of the<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>class is
created, and its constructor is called to allocate dynamic memory
arrays for storing information for all nodes. If necessary, another
instance of<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>class
could be created and initialized here, for example, if the state of the
system at previous time step is needed to calculate mass transport at
the current time step.<span style="font-family: Helvetica,Arial,sans-serif;"><br>
<br>
</span>
<table style="text-align: left; width: 100%; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;"><br>
#include "node.h"<br>
#include "main.h"<br>
      <br>
//The case of data exchange in computer memory<br>
int main( int argc, char* argv[] )<br>
{<br>
&nbsp;&nbsp; // Analyzing command line arguments (default arguments)<br>
&nbsp;&nbsp; char ipm_input_file_list_name[256] = "system-dat.lst";<br>
&nbsp;&nbsp; char dbr_input_file_name[256] = "system-dbr.dat";<br>
      <br>
&nbsp;&nbsp; if (argc &gt;= 2 )&nbsp; // list of files needed as input
for initializing GEMS3K<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy( ipm_input_file_list_name,
argv[1], 256);<br>
&nbsp;&nbsp; if (argc &gt;= 3 ) // input file for boundary conditions<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy( dbr_input_file_name,
argv[2], 256);<br>
      <br>
&nbsp;&nbsp;&nbsp; // Creates a TNode structure instance accessible
through the "node" pointer<br>
&nbsp;&nbsp;&nbsp; TNode* node&nbsp; = new TNode();<br>
      <br>
&nbsp;&nbsp;&nbsp; // (1) Initialization of GEMS3K internal data by
reading&nbsp; files<br>
&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; whose names are given in
the ipm_input_system_file_list_name<br>
&nbsp;&nbsp;&nbsp; if( node-&gt;GEM_init( ipm_input_file_list_name ) )<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
"Error occured during reading the files";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp; // Getting direct access to work node DATABR
structure which exchanges the<br>
&nbsp;&nbsp;&nbsp; // data with GEMS3K (already filled out by reading
the DBR input file)<br>
&nbsp;&nbsp;&nbsp; DATABR* dBR = node-&gt;pCNode();<br>
      <br>
&nbsp;&nbsp;&nbsp; // Getting direct access to the DataCH structure in
GEMS3K instance memory<br>
&nbsp;&nbsp;&nbsp; DATACH* dCH = node-&gt;pCSD();<br>
      <br>
&nbsp;&nbsp;&nbsp; // Creating memory for mass transport nodes<br>
&nbsp;&nbsp;&nbsp; // 11 nodes, 99 time steps<br>
&nbsp;&nbsp;&nbsp; TMyTransport mt( 11, 100, dCH-&gt;nICb,
dCH-&gt;nDCb, dCH-&gt;nPHb, dCH-&gt;nPSb );<br>
      <br>
      </td>
    </tr>
  </tbody>
</table>

<span style="font-family: Helvetica,Arial,sans-serif;"><br>
<br>
</span>The next part of the example sets the initial state of the mass
transport system by taking the data for the chemical system from
GEMS3K. These data were read in upon initialization of the<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">TNode</span><span style="font-family: Helvetica,Arial,sans-serif;">
</span>class instance (see above) and are copied into all nodes but the
zeroth
one. After the GEM calculation for each node, the node status code
is checked in order to assess quality of GEM solution. Initialization
of nodes is done in the same loop with GEM calculations, even
though the bulk composition of the system is constant. This is because,
in general, temperature T and pressure P may change between the nodes,
hence the chemical speciation must be made consistent by recalculating
chemical equilibrium at the respective T and P. In real transport
codes,
this part - setting initial conditions and composition in all nodes -
is much more complex. <br>

<br>

One initial chemical system is read separately in a<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">GEM_read_dbr()</span> call,
then (after calculation of equilibrium at desired T,P) the data is
copied into mass transport arrays for the node with index 0. This node
has
a different composition and will be used by the transport part as a
constant infinite source of MgCl<sub>2</sub>, moved into other nodes
(containing calcium carbonate) over time steps. <br>

<span style="font-family: Helvetica,Arial,sans-serif;"><br>
</span>
<table style="text-align: left; width: 100%; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; // Initialization of GEMS3K and chemical information
for nodes kept in the MT part<br>
&nbsp;&nbsp;&nbsp; long int in;<br>
&nbsp;&nbsp;&nbsp; for(&nbsp; in=1; in&lt; mt.nNodes; in++ )<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Asking GEM IPM to run
with automatic initial approximation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dBR-&gt;NodeStatusCH =
NEED_GEM_AIA;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) re-calculating
equilibrium by calling GEMS3K, getting the status back<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mt.aNodeStatusCH[in] =
node-&gt;GEM_run( false);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !( mt.aNodeStatusCH[in]
== OK_GEM_AIA || mt.aNodeStatusCH[in] == OK_GEM_SIA ) )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "Error occured during re-calculating equilibrium" ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Extracting GEM IPM input
data to mass-transport program arrays<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_restore_MT(
mt.aNodeHandle[in], mt.aNodeStatusCH[in], mt.aT[in], mt.aP[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aVs[in], mt.aMs[in], mt.abIC[in], mt.adul[in], mt.adll[in],
mt.aaPH[in] );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Extracting GEM IPM output
data to mass-transport program arrays<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_to_MT(
mt.aNodeHandle[in], mt.aNodeStatusCH[in], mt.aIterDone[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aVs[in], mt.aMs[in], mt.aGs[in], mt.aHs[in], mt.aIC[in], mt.apH[in],
mt.ape[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aEh[in], mt.arMB[in], mt.auIC[in], mt.axDC[in], mt.agam[in],
mt.axPH[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.avPS[in], mt.amPS[in], mt.abPS[in], mt.axPA[in], mt.aaPh[in],
mt.abSP[in] );<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here the setup of initial
differences between node compositions,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;
temperatures, etc. can be implemented<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here the file output for
the initial conditions can be implemented<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp; // Read DATABR structure from text file (read
boundary condition on the left)<br>
&nbsp;&nbsp;&nbsp; node-&gt;GEM_read_dbr( dbr_input_file_name );<br>
      <br>
&nbsp;&nbsp;&nbsp; for(&nbsp; in=0; in&lt;1; in++ )<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Asking GEM IPM to run
with automatic initial approximation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dBR-&gt;NodeStatusCH =
NEED_GEM_AIA;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) Re-calculating
chemical equilibrium by calling GEM<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mt.aNodeStatusCH[in] =
node-&gt;GEM_run( false );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !( mt.aNodeStatusCH[in]
== OK_GEM_AIA || mt.aNodeStatusCH[in] == OK_GEM_SIA ) )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "Error occured during re-calculating chemical
equilibrium" ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) Extracting GEM IPM
input data to mass-transport program arrays<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_restore_MT(
mt.aNodeHandle[in], mt.aNodeStatusCH[in], mt.aT[in], mt.aP[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aVs[in], mt.aMs[in], mt.abIC[in], mt.adul[in], mt.adll[in],
mt.aaPH[in] );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7) Extracting GEM IPM
output data to mass-transport program arrays<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_to_MT(
mt.aNodeHandle[in], mt.aNodeStatusCH[in], mt.aIterDone[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aVs[in], mt.aMs[in], mt.aGs[in], mt.aHs[in], mt.aIC[in], mt.apH[in],
mt.ape[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aEh[in], mt.arMB[in], mt.auIC[in], mt.axDC[in], mt.agam[in],
mt.axPH[in],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.avPS[in], mt.amPS[in], mt.abPS[in], mt.axPA[in], mt.aaPh[in],
mt.abSP[in] );<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
      </td>
    </tr>
  </tbody>
</table>

<span style="font-family: Helvetica,Arial,sans-serif;"><br>
</span>
<p>The last code snippet below shows how the main loop of coupled
calculations is organized.&nbsp; <br>
<br>
Firstly, the use of access methods for extracting indexes of
independent chemical components and phases is shown.&nbsp; Then, the
stoichiometry of matter to be transported is defined using the<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">stoich[5]</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>work array.
Next, the 'time loop' begins with the 'mass transport' as such
represented as a single<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: monospace;">mt.OneTimeStepRun()</span> function
call; in principle, in this function, also temperature of each node may
change. <br>
<span style="font-family: Helvetica,Arial,sans-serif;"><br>
</span>After that, the nested 'chemical equilibriation loop'&nbsp;
performs
re-calculation of equilibria in all nodes whose bulk composition had
just been modified at the 'mass transport' stage at this time step.
This loop also demonstrates how to use the 'smart initial
approximation' (SIA) mode of GEM IPM. After some output indicating
changes in chemical speciation at this time step in each node,
the&nbsp; chemical equilibration loop is closed, and control goes to
the mass transport time loop. Note that at this stage, various
back-coupling calculations, i.e. how precipitation/dissolution of some
phases has affected the porosity and transport properties, can be
implemented&nbsp; (in a real coupling, of course). <br>
</p>

<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; // Main loop -
iterations over mt.nTimes time steps</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; int xCalcite = node-&gt;Ph_name_to_xDB("Calcite");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; int
xDolomite = node-&gt;Ph_name_to_xDB("Dolomite-dis");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; int
xAq_gen = node-&gt;Ph_name_to_xDB("aq_gen");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; long int
ICndx[5];</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ICndx[0]
= node-&gt;IC_name_to_xDB("Ca");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ICndx[1]
= node-&gt;IC_name_to_xDB("C");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ICndx[2]
= node-&gt;IC_name_to_xDB("O");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ICndx[3]
= node-&gt;IC_name_to_xDB("Mg");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ICndx[4]
= node-&gt;IC_name_to_xDB("Cl");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; //
Checking indexes</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; cout
&lt;&lt; "xCa= " &lt;&lt; ICndx[0] &lt;&lt; " xC=" &lt;&lt; ICndx[1]
&lt;&lt; " xO=" &lt;&lt; ICndx[2] &lt;&lt; " xMg="</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; ICndx[3] &lt;&lt; " xCl=" &lt;&lt; ICndx[4] &lt;&lt; endl
&lt;&lt; " xCalcite=" &lt;&lt; xCalcite</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; " xDolomite=" &lt;&lt; xDolomite &lt;&lt; " xAq_gen=" &lt;&lt;
xAq_gen &lt;&lt; endl &lt;&lt; endl;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; double
stoich[5] = { 0., 0., 0., 1., 2. }; // defines what is 'transported'</span><br style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; long int
it;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; for(
it=0; it&lt; mt.nTimes; it++ )</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "Time step&nbsp; " &lt;&lt; it &lt;&lt; endl;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Mass transport loop over nodes (not a real transport model)</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.OneTimeStepRun( stoich, ICndx, 5 );</span><br style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Chemical equilibration loop over nodes</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for( in=0; in&lt; mt.nNodes; in++ )</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aNodeHandle[in] = in;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aNodeStatusCH[in] = NEED_GEM_SIA;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// (8) Setting input data for GEMIPM to use available node speciation as</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// initial approximation</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_from_MT( mt.aNodeHandle[in], mt.aNodeStatusCH[in],</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aT[in], mt.aP[in], mt.aVs[in], mt.aMs[in],</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.abIC[in], mt.adul[in], mt.adll[in], mt.aaPH[in], mt.axDC[in],
mt.agam[in] );</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// (9)&nbsp;&nbsp; Passing current FMT iteration information into the
work DATABR structure</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_set_MT( (double)it, 1. );</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Calling GEMIPM calculation</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aNodeStatusCH[in] = node-&gt;GEM_run( true );</span><br style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( ( mt.aNodeStatusCH[in] == ERR_GEM_AIA || mt.aNodeStatusCH[in] ==
ERR_GEM_SIA ||</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aNodeStatusCH[in] ==&nbsp; T_ERROR_GEM ) )</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "Error: GEM calculation results are not retrieved. Time
step"</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; it &lt;&lt; " node " &lt;&lt; in &lt;&lt; endl;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( ( mt.aNodeStatusCH[in] == BAD_GEM_AIA || mt.aNodeStatusCH[in] ==
BAD_GEM_SIA&nbsp; ) )</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "Insufficient quality of GEM solution, but GEM results
are retrieved"</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; it &lt;&lt; " node " &lt;&lt; in &lt;&lt; endl;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      </span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else // (7) Extracting GEMIPM output data to FMT part</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node-&gt;GEM_to_MT( mt.aNodeHandle[in], mt.aNodeStatusCH[in],
mt.aIterDone[in],</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aVs[in], mt.aMs[in], mt.aGs[in], mt.aHs[in], mt.aIC[in], mt.apH[in],
mt.ape[in],</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.aEh[in],mt.arMB[in], mt.auIC[in], mt.axDC[in], mt.agam[in],
mt.axPH[in],</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mt.avPS[in], mt.amPS[in], mt.abPS[in], mt.axPA[in], mt.aaPh[in], </span><span style="font-family: monospace;">mt.abSP[in] );</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Here, the output upon completion of the time step is usually
implemented</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp; to monitor the coupled simulation or collect results</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "&nbsp; Node " &lt;&lt; in ;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; ": Aq= " &lt;&lt; mt.axPH[in][xAq_gen] &lt;&lt; " pH= "
&lt;&lt; mt.apH[in] &lt;&lt;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"&nbsp; Calcite= " &lt;&lt; mt.axPH[in][xCalcite] &lt;&lt; endl;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; }</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; // Calculations
finished - end time step reached</span><br style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; // Final output,
e.g. of total simulation time or of the final distribution of</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; //&nbsp; components
and phases in all nodes, can be implemented here</span><br style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; // deleting GEMS3K
and data exchange memory structures</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; delete node;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; // end of example</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; return 0;<br>
&nbsp; // no need to call the TMyTransport destructor in this case<br>
}<br>
      </span></td>
    </tr>
  </tbody>
</table>

<br>

<br>

<hr size="2" width="100%">
<h3><a name="TAG_FAQ"></a>4. Frequently asked questions</h3>

<p>&nbsp;
&lt;under construction&gt;<br>
</p>

<hr size="2" width="100%">
<p> </p>

<p>Last change: 29.09.2012 DK<br>

</p>

<p>Copyright (c) 2012 <a href="http://gems.web.psi.ch/teamhist.html">GEMS Development Team</a></p>
<p><br>
&nbsp; </p>


<br>

<br>

</body></html>