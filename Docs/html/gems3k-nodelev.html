<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
    <meta name="GENERATOR" content="Mozilla/4.72 [en]C-BLUEWIN-CH20  (Win98; I) [Netscape]">
    <title>How to couple codes with GEMS3K at simple level</title>
  </head>
  <body style="background-image: url(bgimg-gray.jpg);">
    <h1><img src="gems1.png" align="left" height="48" width="48">
      GEMS3K Solver of GeoChemical Equilibria<br>
    </h1>
    <p> </p>
    <h2>Coupling with GEMS3K at Simple TNode Level</h2>
    <hr size="2" width="100%">
    <h3>Contents</h3>
    <p><a href="#TAG_INTRO">1. Introduction</a></p>
    <p><a href="#TAG_DISKONLY">2. Data exchange using disk files only</a></p>
    <p><a href="#TAG_MEMEXCHANGE">3. Data exchange in computer memory</a> </p>
    <p><a href="#TAG_FAQ">4. Frequently asked questions</a></p>
    <br>
    <hr size="2" width="100%">
    <h3><a name="TAG_INTRO"></a>1. Introduction<br>
    </h3>
    <p class="MsoNormal" style="margin-bottom: 6pt; text-align: left;">The&nbsp;
      <tt>main.cpp</tt>&nbsp;
      file
      in "<tt>standalone/gemcalc/</tt>" folder
      shows how to perform a batch calculation of chemical equilibria using
      the input
      data given in DCH, IPM and one or more DBR files; the results are
      written into
      DBR files or (optionally) into a dump text output file.&nbsp; </p>
    <p class="MsoNormal" style="margin-bottom: 6pt; text-align: left;"><tt>M</tt><tt>ain.cpp</tt>
      and <tt>main.h</tt>&nbsp; files
      in&nbsp; "<tt>standalone/node-gem</tt>/" folder&nbsp;
      shows how the coupling with a "transport part" having
      several nodes can be arranged, where the chemical data and parameters
      are kept
      in dynamic arrays and exchanged with the GEMS3K in computer memory.
      The modification to a &#8220;real&#8221; mass transport method is
      straightforward, although this would make the example program too
      complicated.&nbsp; </p>
    In
    these examples,
    some options are shown that may significantly improve performance and
    accuracy
    of GEMS3K.&nbsp; <br>
    <p>As the mass
      transport part has no direct access to internal IPM work data, the
      calculations
      of equilibria occur as if they were done in &#8220;real&#8221; amounts consistent
      with the
      current size of the node. The use of internal re-scaling mechanism
      leads, in general,
      to a much
      better convergence of GEMS3K and to higher precision of its results.</p>
    <p>The current
      chemical speciation (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
      vector, amounts
      of Dependent Components) is usually the output from GEM IPM
      runs (can also be used as input initial approximation in SIA mode). The
      ultimate
      input of GEMS3K is the bulk chemical composition vector (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>),
temperature
      and
      pressure. So, at time steps, the mass transport part should change the <span
        style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
      vector
      and,
      maybe, <i>T</i>
      and/or <i>P</i> in every node, and
      this must be sufficient.&nbsp; &nbsp;&nbsp;
    </p>
    <p>However, in many
      existing advection/diffusion transport codes (e.g.
      OpenGeoSys),&nbsp;not
      the total amounts of independent components, but rather the amounts of
      aqueous
      species are moved between nodes. Conversely, after the mass transport
      step,
      only the speciation vector <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
      is changed in
      each node, and an additional step would be needed to compute a
      corrected <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
      vector
      (i.e. elemental bulk composition) in the mass transport part, which
      will be the
      GEM input for computing the new speciation <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>.
      &nbsp;In
      turn, this would require access to several data objects (such as the A
      stoichiometry
      matrix) in the <tt>DATACH</tt> structure.<span style="font-family: Helvetica,Arial,sans-serif;"></span></p>
    <p><span style="font-family: Helvetica,Arial,sans-serif;"></span></p>
    <p>In order to make this
      unnecessary, the TNode class provides
      a variant of <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">GEM_from_MT()</span>
      function call
      where the re-calculation of input (changed) <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
      speciation into
      new <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
      bulk composition
      vector is performed inside of GEMS3K before the internal mass scaling
      and calculation
      of new equilibrium state. Actually, total amounts of Independent
      Components are
      calculated from stoichiometries of Dependent Components (as provided in
      the A matrix) and their
      amounts (in the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
      vector passed
      through the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_xDC</span>
      parameter), and
      then added to the amounts given in the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
      vector
      (passed through <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_bIC</span>
      parameter).
      Here,
      two cases are possible. One case is when the mass transport step puts
      in the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_xDC</span>
      parameter the differences
      between the new and the old speciation in the node chemical system. In
      this
      case, the old <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_bIC</span>
      content (e.g.
      unchanged since the last GEM calculation for this node) must be
      provided and it will be automatically corrected.&nbsp; Another (more
      usual) case
      is when the mass-transport part delivers in <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_xDC</span>
      the
      complete new
      speciation (absolute
      amounts) after the transport time step. In this case, the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">p_bIC</span>
      vector must be
      filled with zeros because its new content will be completely retrieved
      from the
      p_<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
      vector.
    </p>
    <p>Concerning the &#8220;Smart
      Initial Approximation&#8221; (SIA) mode,
      the TNode class contains a parameter in <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">GEM_run()</span>
      call and yet another
      variant of <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">GEM_from_MT()</span>
      function that
      control what initial approximation of GEM speciation vector will
      be used. Basically, regardless of what the mass transport part does,
      the GEMS3K can use previous contents of
      speciation
      and activity coefficients vectors in MULTI structure as an initial
      approximation for the next GEM calculation &#8211; even if the bulk
      composition b or
      temperature T have had changed. This mode is set by the default <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">uPrimalSol</span>
      parameter value
      (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">false</span>).
    </p>
    <p>Another, more
      efficient variant (<span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">uPrimalSol
        = true</span>)
      can be used when
      the mass transport part directly changes the chemical speciation in the
      node while
      taking care of material balance, and the <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">bIC</span>
      input
      vector must be
      restored anyway from
      the new <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">xDC</span>
      vector contents
      (provided together with activity coefficients stored for this
      node at previous time step). In this case, the SIA mode is very
      efficient because
      the mass balance is already ensured, and this may lead to a very
      serious reduction
      of the number of GEM iterations and total computing time. &nbsp;Note
      that this
      SIA mode works only when the
      DATACH structure contains a full list of Dependent Components used in
      GEM calculations.
    </p>
    <p>The
      TNode
      class provides dozens of access methods to single items of chemical
      data. Usage
      of these public methods is strongly preferred over direct access to
      fields of
      the DATABR and DATACH memory structures. The
      provided methods use either DATABR or DATACH indexation. </p>
    In DBR files
    and DATABR structure, the results for volumes, masses and bulk
    compositions are
    only provided for multi-component phases, because for pure phases they
    can be
    easily retrieved. Nevertheless, TNode public functions such as <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">Ph_Volume(),
      Ph_Mass(),
      Ph_BC()</span> and
    <span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">Ph_SatInd()</span>
    work both for
    multi- and single-component phases. This is done in order to make
    access to such data from the side of mass-transport part of the program
    as simple
    as possible.<br>
    <br>
    <hr size="2" width="100%">
    <h3><a name="TAG_DISKONLY"></a>2. Data exchange using disk files only</h3>
    <p><span style="font-family: Helvetica,Arial,sans-serif;">Programming
        example fragment (see full example in </span><big><span style="font-family: monospace;">"<small>standalone/gemcalc/main.cpp</small></span></big><span
        style="font-family: Helvetica,Arial,sans-serif;">"): </span></p>
    <span style="font-family: monospace;"></span><span style="font-family: monospace;"></span>
    <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><tt>#include "node.h"</tt><tt><br>
            </tt><tt> </tt><tt>&nbsp;&nbsp; </tt><tt><br>
            </tt><tt>int main( int argc, char* argv[] )<br>
              &nbsp;{<br>
              &nbsp;&nbsp; long nRecipes = 0;<br>
              &nbsp;&nbsp; char (*recipes)[fileNameLength] = 0;<br>
              &nbsp;&nbsp; <br>
              &nbsp;&nbsp; // Analyzing command line arguments<br>
              &nbsp;&nbsp; // Default arguments<br>
              &nbsp;&nbsp; char input_system_file_list_name[256] =
              "system-dat.lst";<br>
              &nbsp;&nbsp; char input_recipes_file_list_name[256] =
              "more_recipes.lst";<br>
              &nbsp;&nbsp; <br>
              &nbsp;&nbsp; if (argc &gt;= 2 )<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(
              input_system_file_list_name, argv[1], 256);<br>
              &nbsp;&nbsp; // list of DCH, IPM and DBR input files for
              initializing GEMS3K<br>
              &nbsp;&nbsp; <br>
              &nbsp;&nbsp; // Creates TNode structure instance accessible trough
              the "node" pointer<br>
              &nbsp;&nbsp; TNode* node&nbsp; = new TNode();<br>
              &nbsp; <br>
              &nbsp;&nbsp; // (1) Initialization of GEMS3K internal data by
              reading&nbsp; files<br>
              &nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; whose names are given in
              the input_system_file_list_name<br>
              &nbsp;&nbsp; if( node-&gt;GEM_init( input_system_file_list_name )
              )<br>
              &nbsp;&nbsp; {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error occured during reading the
              files<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>
              &nbsp;&nbsp; }<br>
              <br>
              &nbsp;&nbsp; // Getting direct access to work node DATABR
              structure which exchanges the<br>
              &nbsp;&nbsp; // data with GEM IPM3 (already filled out by reading
              the DBR input file)<br>
              &nbsp;&nbsp; DATABR* dBR = node-&gt;pCNode(); </tt><tt></tt><tt><br>
            </tt><tt><br>
            </tt><tt>// . . . . . . . . . . . . . . .<br>
            </tt><br>
            <tt>&nbsp;&nbsp; // Asking GEM to run with automatic initial
              approximation <br>
              &nbsp;&nbsp; dBR-&gt;NodeStatusCH = NEED_GEM_AIA;<br>
              <br>
              &nbsp;&nbsp; // (2) re-calculating equilibrium by calling GEMS3K,
              getting the status back<br>
              &nbsp;&nbsp; int NodeStatusCH = node-&gt;GEM_run( false );<br>
              <br>
              &nbsp;&nbsp; if( NodeStatusCH == OK_GEM_AIA || NodeStatusCH ==
              OK_GEM_SIA&nbsp; )<br>
              &nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // (3) Writing results in default
              DBR file<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_write_dbr( NULL,
              false, true, false );<br>
              // &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_print_ipm( NULL
              );&nbsp;&nbsp; // possible debugging printout<br>
              &nbsp;&nbsp; }<br>
              &nbsp;&nbsp; else {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4) possible return status
              analysis, error message<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_print_ipm( NULL
              );&nbsp;&nbsp; // possible debugging printout<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 5; // GEM IPM did not
              converge properly - error message needed<br>
              &nbsp;&nbsp; }<br>
            </tt><tt></tt><tt><br>
            </tt><tt>// . . . . . . . . . . . . . . .<br>
            </tt><br>
            <tt>&nbsp;&nbsp; // Here a possible loop on more input recipes
              begins<br>
              &nbsp;&nbsp; if (argc &gt;= 3 )<br>
              &nbsp;&nbsp; {&nbsp; <br>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; char NextRecipeFileName[256];<br>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; char NextRecipeOutFileName[300];<br>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; char
              input_recipes_file_list_path[256-fileNameLength] = "";<br>
              &nbsp;&nbsp;&nbsp;&nbsp; <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(
              input_recipes_file_list_name, argv[2], 256);<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // list of additional recipes
              (dbr.dat files) e.g. for simulation<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of a titration or another
              irreversible process<br>
              &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; // Reading list of recipes names
              from file <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recipes = f_getfiles(&nbsp;
              input_recipes_file_list_name,<br>
              &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
              &nbsp;input_recipes_file_list_path, nRecipes,
              ',');&nbsp;&nbsp;&nbsp;
              &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int cRecipe=0; cRecipe &lt;
              nRecipes; cRecipe++ )<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Trying to read
              the next file name <br>
              &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
              sprintf(NextRecipeFileName
              , "%s%s", input_recipes_file_list_path, recipes[cRecipe] );<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5) Reading the next
              DBR file with different input composition or temperature<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_read_dbr(
              NextRecipeFileName );<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Asking GEM IPM2 to
              run (faster) with smart initial approximation <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dBR-&gt;NodeStatusCH =
              NEED_GEM_SIA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NodeStatusCH =
              node-&gt;GEM_run( false );<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( NodeStatusCH ==
              OK_GEM_AIA || NodeStatusCH == OK_GEM_SIA&nbsp; )<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;
              sprintf(NextRecipeOutFileName , "%s.out", NextRecipeFileName );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
              &nbsp;node-&gt;GEM_write_dbr( NextRecipeOutFileName, false, false,
              false );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sprintf(NextRecipeOutFileName
              , "%s.Dump.out", NextRecipeFileName );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              node-&gt;GEM_print_ipm( NextRecipeOutFileName );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              // error message, debugging printout<br>
              &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(NextRecipeOutFileName ,
              "%s.Dump.out", NextRecipeFileName );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              node-&gt;GEM_print_ipm( NextRecipeOutFileName );<br>
              //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return
              5; // GEM IPM did not converge properly - error message needed<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              }<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
              &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; &nbsp;<br>
              &nbsp;&nbsp; // end of possible loop on input recipes<br>
              &nbsp;&nbsp; delete node;<br>
              &nbsp;&nbsp; if( recipes ) delete recipes;<br>
              <br>
              &nbsp;// End of example&nbsp; <br>
              &nbsp;&nbsp; return 0; <br>
              }&nbsp; </tt><span style="font-family: monospace;"><br>
            </span></td>
        </tr>
      </tbody>
    </table>
    <span style="font-family: monospace;"></span><br>
    In this example, the GEMS3K input file names are provided in two .lst
    text files, whose paths are given as command line arguments. The second
    list (passed when argc &gt;= 3) may contain one or many DBR input files
    (for systems at different T, P, or bulk composition). These files are
    processed in a loop; the function f_getfiles also counts how many file
    names are in the .lst files. The input DBR files must be provided (e.g.
    exported from GEM-Selektor or cloned/modified using a text editor) in
    the same folder as the .lst files. <br>
    <br>
    <hr size="2" width="100%">
    <h3><a name="TAG_MEMEXCHANGE"></a>3. Data exchange in computer memory </h3>
    <p>This case is
      typical for coupling GEMS3K with an existing reactive
      mass transport code that has its own data structure for keeping
      chemical information (e.g. speciation, bulk composition of the system)
      for each node. As in the previous example, it uses one work instance of
      the <span style="font-family: monospace;">DATABR</span><span style="font-family: Helvetica,Arial,sans-serif;">
      </span>memory
      structure as data bridge for the exchange with internal GEM IPM data
      structures. <br>
    </p>
    <p>
      This example code consists of two C++ files: "<tt>main.h</tt>" and "<tt>main.cpp</tt>",
located
      in the "<tt>standalone/node-gem/</tt>" folder. The former file
      contains a definition of<span style="font-family: Helvetica,Arial,sans-serif;">
      </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
      </span>class representing a typical dynamic memory structure used for
      keeping current chemical composition and speciation for all nodes
      involved in the reactive mass transport system. The latter file
      contains
      an implementation of some public methods of<span style="font-family: Helvetica,Arial,sans-serif;">
      </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
      </span>class, as
      well as the main function which shows the sequence of calls to<span style="font-family: Helvetica,Arial,sans-serif;">
      </span><span style="font-family: monospace;">TNode</span><span style="font-family: Helvetica,Arial,sans-serif;">
      </span>class functions, necessary to perform coupled reactive transport
      calculations based on the "operator splitting" approach. <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      </span></p>
    <p>This example
      is designed to help learning how to couple the existing transport code
      with GEMS3K in a simple way, and it does not contain a 'real' transport
      code which would make the example more difficult to observe. The
      transport model itself is located in the <tt>TMyTransport::OneTimeStepRun()</tt>
      function and can be improved there to any desired extent. <br>
    </p>
    <p><span style="font-family: Helvetica,Arial,sans-serif;"></span></p>
    <span style="font-family: Helvetica,Arial,sans-serif;">
    </span>
    <p>Here is a code snippet with the<span style="font-family: Helvetica,Arial,sans-serif;">
      </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
      </span>class
      definition (see complete code in
      <span style="font-family: monospace;">standalone/node-gem/main.h</span>):
      <span style="font-family: monospace;"></span></p>
    <span style="font-family: monospace;">
    </span><span style="font-family: Helvetica,Arial,sans-serif;"></span>
    <table style="text-align: left; width: 100%; font-family: monospace;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;">#include "node.h"<br>
            <br>
            class TMyTransport<br>
            {<br>
            &nbsp;public:<br>
            &nbsp;&nbsp;&nbsp; long int nNodes,&nbsp; // Number of mass
            transport nodes<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            nTimes,&nbsp;&nbsp; // Number of time steps<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            nIC,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical independent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            nDC,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical dependent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            nPH,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical phases<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            nPS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical
            phases-solutions<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            nRecipes; // Number of different input node recipes to set boundary
            conditions<br>
            <br>
            &nbsp;&nbsp;&nbsp; long int *aNodeHandle,&nbsp;&nbsp;&nbsp;&nbsp; //
            Node identification handles<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aNodeStatusCH,&nbsp;&nbsp;
            // Node status codes (changed after GEM
            calculation)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*aIterDone;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            // Number of GEM IPM
            iterations performed for each node<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;&nbsp;
            at the last time step<br>
            <br>
            &nbsp;&nbsp;&nbsp; double *aT,&nbsp;&nbsp;&nbsp;&nbsp; // Array of
            node temperatures T, Kelvin<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aP,&nbsp;&nbsp;&nbsp;&nbsp; // Array of node pressures P, Pa<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aVs,&nbsp;&nbsp;&nbsp; // Array of node volume V of reactive
            subsystem, m3<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aMs,&nbsp;&nbsp;&nbsp; // Array of node mass of reactive subsystem,
            kg<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aGs,&nbsp;&nbsp;&nbsp; // Array of node total Gibbs energy of
            reactive
            subsystems, J<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aHs,&nbsp;&nbsp;&nbsp; // Array of node total enthalpy of reactive
            subsystems, J (reserved)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aIC,&nbsp;&nbsp;&nbsp; // Array of node effective aqueous ionic
            strengths, molal<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *apH,&nbsp;&nbsp;&nbsp; // Array of node pH of aqueous solutions<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *ape,&nbsp;&nbsp;&nbsp; // Array of node pe of aqueous solutions<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            *aEh;&nbsp;&nbsp;&nbsp; // Array of node Eh of aqueous solution, V<br>
            <br>
            &nbsp;&nbsp;&nbsp; double **axDC,&nbsp; // Array of node mole
            amounts of dependent components (speciation)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **agam,&nbsp; // Array of node activity coefficients of dependent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **axPH,&nbsp; // Array of node total mole amounts of all reactive
            phases<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **aaPH,&nbsp; // Array of node specific surface areas of phases,
            m2/kg<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **avPS,&nbsp; // Array of node total volumes of multicomponent
            phases,
            m3<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **amPS,&nbsp; // Array of node total masses of multicomponent
            phases,kg<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **abPS,&nbsp; // Array of node bulk compositions of multicomponent
            phases, moles<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **axPA,&nbsp; // Array of node amount of carrier in asymmetric
            phases,
            moles<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **aaPh,&nbsp; // Array of node surface areas of phases, m2<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **adul,&nbsp; // Array of node upper restrictions to amounts of
            dependent components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **adll,&nbsp; // Array of node lower restrictions to amounts of
            dependent components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **abIC,&nbsp; // Array of node bulk mole amounts of independent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **arMB,&nbsp; // Array of node mole balance residuals for
            independent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **auIC,&nbsp; // Array of node chemical potentials of independent
            components (norm.)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            **abSP;&nbsp; // Array for bulk composition of solid part of
            equilibrated sub-system<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMyTransport(&nbsp;&nbsp;
            // Constructor (dynamic memory allocation)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int p_nNod,&nbsp;&nbsp;&nbsp; // Number of nodes<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int p_nTim,&nbsp;&nbsp;&nbsp; // Number of time steps<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int
            p_nIC,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical independent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int
            p_nDC,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical dependent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int
            p_nPH,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical phases<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int
            p_nPS,&nbsp;&nbsp;&nbsp;&nbsp; // Number of chemical phases -
            solutions<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
            int
            p_nRcps&nbsp;&nbsp;&nbsp; // Number of different input node recipes
            to
            set boundary conditions<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            );<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~TMyTransport();&nbsp; //
            Destructor of dynamic memory<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
            OneTimeStepRun(&nbsp;&nbsp; // Placeholder function for one
            transport
            time step<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            long
            int *ICndx,&nbsp;&nbsp;&nbsp; // Indexes of mobile independent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            long
            int nICndx&nbsp;&nbsp;&nbsp;&nbsp; // Number of mobile independent
            components<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            );<br>
            };<br>
            <br>
          </td>
        </tr>
      </tbody>
    </table>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span>
    <p>All data and
      methods in this class are declared as 'public' to make the example
      program more straightforward. The three functions belonging to<span style="font-family: Helvetica,Arial,sans-serif;">
      </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
      </span>class are
      implemented in the<span style="font-family: Helvetica,Arial,sans-serif;"></span>
      "<span style="font-family: monospace;">standalone/node-gem/main.cpp</span>"
      file as follows:</p>
    <p><span style="font-family: Helvetica,Arial,sans-serif;"></span></p>
    <span style="font-family: Helvetica,Arial,sans-serif;"></span>
    <table style="text-align: left; width: 100%; font-family: monospace;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;">#include "node.h"<br>
            #include "main.h"<br>
            <br>
            TMyTransport::TMyTransport( long int p_nNod, long int p_nTim, long
            int p_nIC, long int p_nDC,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
long
            int p_nPH, long int p_nPS, long int p_nRcps )<br>
            {<br>
            <br>
            &nbsp;&nbsp;&nbsp; nNodes = p_nNod;<br>
            &nbsp;&nbsp;&nbsp; nTimes = p_nTim;<br>
            &nbsp;&nbsp;&nbsp; nIC = p_nIC;<br>
            &nbsp;&nbsp;&nbsp; nDC = p_nDC;<br>
            &nbsp;&nbsp;&nbsp; nPH = p_nPH;<br>
            &nbsp;&nbsp;&nbsp; nPS = p_nPS;<br>
            &nbsp;&nbsp;&nbsp; nRecipes = p_nRcps;<br>
            <br>
            &nbsp;&nbsp;&nbsp; aNodeHandle = new long int [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aNodeStatusCH = new long int [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aIterDone = new long int [nNodes];<br>
            <br>
            &nbsp;&nbsp;&nbsp; aT = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aP = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aVs = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aMs = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aGs = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aHs = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aIC = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; apH = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; ape = new double [nNodes];<br>
            &nbsp;&nbsp;&nbsp; aEh = new double [nNodes];<br>
            <br>
            &nbsp;&nbsp;&nbsp; axDC = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; agam = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; axPH = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; aaPH = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; avPS = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; amPS = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; abPS = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; axPA = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; aaPh = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; adul = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; adll = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; abIC = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; arMB = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; auIC = new double *[nNodes];<br>
            &nbsp;&nbsp;&nbsp; abSP = new double *[nNodes];<br>
            <br>
            &nbsp;&nbsp;&nbsp; for (long int in=0; in&lt;nNodes; in++)<br>
            &nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abIC[in] = new
            double [nIC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arMB[in] = new
            double [nIC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auIC[in] = new
            double [nIC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; axDC[in] = new
            double [nDC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; agam[in] = new
            double [nDC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adul[in] = new
            double [nDC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adll[in] = new
            double [nDC];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaPH[in] = new
            double [nPH];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; axPH[in] = new
            double [nPH];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; avPS[in] = new
            double [nPS];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amPS[in] = new
            double [nPS];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; axPA[in] = new
            double [nPS];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaPh[in] = new
            double [nPH];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abPS[in] = new
            double [nIC*nPS];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abSP[in] = new
            double [nIC];<br>
            &nbsp;&nbsp;&nbsp; }<br>
            }<br>
            <br>
            <br>
            TMyTransport::~TMyTransport()<br>
            {<br>
            &nbsp; &nbsp; // Deleting chemical data arrays for nodes<br>
            &nbsp;&nbsp;&nbsp; for (long int in=0; in&lt;nNodes; in++)<br>
            &nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]abIC[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]arMB[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]auIC[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]axDC[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]agam[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]adul[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]adll[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]aaPH[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]axPH[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]avPS[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]amPS[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]axPA[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]aaPh[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]abPS[in];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]abSP[in];<br>
            &nbsp;&nbsp;&nbsp; }<br>
            &nbsp;&nbsp;&nbsp; delete[]axDC;<br>
            &nbsp;&nbsp;&nbsp; delete[]agam;<br>
            &nbsp;&nbsp;&nbsp; delete[]axPH;<br>
            &nbsp;&nbsp;&nbsp; delete[]aaPH;<br>
            &nbsp;&nbsp;&nbsp; delete[]avPS;<br>
            &nbsp;&nbsp;&nbsp; delete[]amPS;<br>
            &nbsp;&nbsp;&nbsp; delete[]abPS;<br>
            &nbsp;&nbsp;&nbsp; delete[]axPA;<br>
            &nbsp;&nbsp;&nbsp; delete[]aaPh;<br>
            &nbsp;&nbsp;&nbsp; delete[]adul;<br>
            &nbsp;&nbsp;&nbsp; delete[]adll;<br>
            &nbsp;&nbsp;&nbsp; delete[]abIC;<br>
            &nbsp;&nbsp;&nbsp; delete[]arMB;<br>
            &nbsp;&nbsp;&nbsp; delete[]auIC;<br>
            &nbsp;&nbsp;&nbsp; delete[]abSP;<br>
            <br>
            &nbsp;&nbsp;&nbsp; delete[]aNodeHandle;<br>
            &nbsp;&nbsp;&nbsp; delete[]aNodeStatusCH;<br>
            &nbsp;&nbsp;&nbsp; delete[]aIterDone;<br>
            &nbsp;&nbsp;&nbsp; delete[]aT;<br>
            &nbsp;&nbsp;&nbsp; delete[]aP;<br>
            &nbsp;&nbsp;&nbsp; delete[]aVs;<br>
            &nbsp;&nbsp;&nbsp; delete[]aMs;<br>
            &nbsp;&nbsp;&nbsp; delete[]aGs;<br>
            &nbsp;&nbsp;&nbsp; delete[]aHs;<br>
            &nbsp;&nbsp;&nbsp; delete[]aIC;<br>
            &nbsp;&nbsp;&nbsp; delete[]apH;<br>
            &nbsp;&nbsp;&nbsp; delete[]ape;<br>
            &nbsp;&nbsp;&nbsp; delete[]aEh;<br>
            }<br>
            <br>
            // A very simple example of finite difference transport algorithm<br>
            // Contributed by Alina Yapparova, MU Leoben, Austria<br>
            //<br>
            void TMyTransport::OneTimeStepRun( long int *ICndx, long int nICndx
            )<br>
            {<br>
            &nbsp;&nbsp;&nbsp; double column_length&nbsp; = 0.5; // [m]<br>
            &nbsp;&nbsp;&nbsp; double dx = column_length/(nNodes-1);<br>
            <br>
            &nbsp;&nbsp;&nbsp; //constant velocity field<br>
            &nbsp;&nbsp;&nbsp; double v = 1.e-5; // velocity [m/s]<br>
            &nbsp;&nbsp;&nbsp; // stability requirement: dt&lt;=dx/velocity, so
            we can choose any coefficient k&lt;1<br>
            &nbsp;&nbsp;&nbsp; double k = 0.1; // k = dt/dx*v<br>
            &nbsp;&nbsp;&nbsp; // calculate dt<br>
            &nbsp;&nbsp;&nbsp; double dt = k*dx/v;<br>
            &nbsp;&nbsp;&nbsp; // and print dt into the output file<br>
            &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\tdt = " &lt;&lt; dt &lt;&lt; "[s]"
            &lt;&lt; endl;<br>
            <br>
            &nbsp;&nbsp;&nbsp; //Finite difference approximation for the
            equation dc/dt + v*dc/dx = 0<br>
            &nbsp;&nbsp;&nbsp; // explicit time, left spatial derivative<br>
            &nbsp;&nbsp;&nbsp; // (c^{n+1}_{i} - c^{n}_{i})/dt + v*(c^{n}_{i} -
            c^{n}_{i-1})/dx = 0<br>
            &nbsp;&nbsp;&nbsp; // c^{n+1}_{i} = (1 - k)*c^{n}_{i} +
            k*c^{n}_{i-1}<br>
            &nbsp;&nbsp;&nbsp; long int in;<br>
            &nbsp;&nbsp;&nbsp; for(&nbsp; in=1; in&lt; nNodes; in++ )<br>
            &nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0;
            i&lt;nICndx; i++)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            abIC[in][ICndx[i]] = (1 - k)*abPS[in][ICndx[i]] +
            k*abPS[in-1][ICndx[i]] + abSP[in][ICndx[i]];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            // where abPS is the total amount of an independent component
            ICndx[i] in the aqueous phase <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp; (after GEM computation)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            // abSP is the total amount of an independent component ICndx[i] in
            ALL solid phases<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            // abIC is the total amount of ICndx[i] that will serve as an input
            constraint for <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp; GEM computation at the next time level<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            // NB: more precisely, one should write abPS[in][n*nIC + ICndx[i]],
            where 0=&lt;n&lt;=nPS, <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp; and transport each phase-solution separately<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp; but as far as an aqueous phase is the first in the
            list (n=0), this simplified indexing <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp; will work for transport of aq phase<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
            &nbsp;&nbsp;&nbsp; }<br>
            }<br>
            <br>
          </td>
        </tr>
      </tbody>
    </table>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span>The last function<span style="font-family: Helvetica,Arial,sans-serif;">
    </span><span style="font-family: monospace;">OneTimeStepRun()</span><span style="font-family: Helvetica,Arial,sans-serif;">
    </span>is an implementation of a 'real' mass transport integration time
    step, which modifies bulk chemical
    composition of nodes by shifting some amounts of elements from one node
    to another, using the zeroth node as an infinite source of constant
    composition ( MgCl<sub>2</sub> solution in this example). It is called for
    each node at each time step (see below). <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      &nbsp;&nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;">
      &nbsp; </span><br>
    The first part of <tt>main.cpp</tt> (see full example in
    <span style="font-family: monospace;">"standalone/node-gem/main.cpp</span>")
    creates the <tt>TNode</tt> class instance and initializes it by
    reading three GEMS3K input files (provided in<span style="font-family: Helvetica,Arial,sans-serif;">
      <tt>"standalone</tt></span><span style="font-family: monospace;">/node-gem-build/tp_test/</span>"),
which
    it extracts from the file list passed through the first command
    line argument. Then an instance of the<span style="font-family: Helvetica,Arial,sans-serif;">
    </span><span style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
    </span>class is
    created, and its constructor is called to allocate dynamic memory
    arrays for storing information for all nodes. If necessary, another
    instance of<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span
      style="font-family: monospace;">TMyTransport</span><span style="font-family: Helvetica,Arial,sans-serif;">
    </span>class
    could be created and initialized here, for example, if the state of the
    system at previous time step is needed to calculate mass transport at
    the current time step.<span style="font-family: Helvetica,Arial,sans-serif;"><br>
      <br>
    </span>
    <table style="text-align: left; width: 100%; font-family: monospace;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><br>
            #include "main.h"<br>
            #include &lt;time.h&gt;<br>
            time_t start,end;<br>
            <br>
            //The case of data exchange in computer memory<br>
            int main( int argc, char* argv[] )<br>
            {<br>
            &nbsp;&nbsp; char (*recipes)[fileNameLength] = 0;<br>
            <br>
            &nbsp;&nbsp; // Analyzing command line arguments ( Default
            arguments)<br>
            &nbsp;&nbsp; char input_system_file_list_name[256] =
            "system-dat.lst";<br>
            &nbsp;&nbsp; char input_recipes_file_list_name[256] =
            "more_recipes.lst";<br>
            <br>
            &nbsp;&nbsp; if (argc &gt;= 2 )<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(
            input_system_file_list_name, argv[1], 256);<br>
            &nbsp;&nbsp; // list of DCH, IPM and DBR input files for
            initializing GEMS3K<br>
            &nbsp;&nbsp; if (argc &gt;= 3 ) // list of DBR files for setting
            boundary conditions<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(
            input_recipes_file_list_name, argv[2], 256);<br>
            <br>
            &nbsp;&nbsp;&nbsp; // Creates TNode structure instance accessible
            trough the "node" pointer<br>
            &nbsp;&nbsp;&nbsp; TNode* node&nbsp; = new TNode();<br>
            <br>
            &nbsp;&nbsp;&nbsp; // (1) Initialization of GEMS3K internal data by
            reading&nbsp; files<br>
            &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; whose names are given
            in the ipm_input_system_file_list_name<br>
            &nbsp;&nbsp;&nbsp; if( node-&gt;GEM_init(
            input_system_file_list_name ) )<br>
            &nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
            "Error occured during reading the files" ;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>
            &nbsp;&nbsp;&nbsp; }<br>
            <br>
            &nbsp;&nbsp;&nbsp; // Getting direct access to work node DATABR
            structure which exchanges the<br>
            &nbsp;&nbsp;&nbsp; // data with GEMS3K (already filled out by
            reading the DBR input file)<br>
            &nbsp;&nbsp;&nbsp; DATABR* dBR = node-&gt;pCNode();<br>
            <br>
            &nbsp;&nbsp;&nbsp; // Getting direct access to DataCH structure in
            GEMS3K instance memory<br>
            &nbsp;&nbsp;&nbsp; DATACH* dCH = node-&gt;pCSD();<br>
            <br>
            &nbsp;&nbsp;&nbsp; // Creating memory for mass transport nodes<br>
            &nbsp;&nbsp;&nbsp; // 11 nodes, 99 time steps<br>
            &nbsp;&nbsp;&nbsp; //TMyTransport mt( 11, 100, dCH-&gt;nICb,
            dCH-&gt;nDCb, dCH-&gt;nPHb, dCH-&gt;nPSb, 1 );<br>
            &nbsp;&nbsp;&nbsp; // 101 nodes, 500 time steps<br>
            &nbsp;&nbsp;&nbsp; TMyTransport mt( 101, 500, dCH-&gt;nICb,
            dCH-&gt;nDCb, dCH-&gt;nPHb, dCH-&gt;nPSb, 1 );<br>
            &nbsp;&nbsp;&nbsp; ...<br>
            <br>
          </td>
        </tr>
      </tbody>
    </table>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      <br>
    </span>The next part of the example sets the initial state of the mass
    transport system by taking the data for the chemical system from
    GEMS3K. These data were read in upon initialization of the<span style="font-family: Helvetica,Arial,sans-serif;">
    </span><span style="font-family: monospace;">TNode</span><span style="font-family: Helvetica,Arial,sans-serif;">
    </span>class instance (see above) and are copied into all nodes but the
    zeroth
    one. After the GEM calculation for each node, the node status code
    is checked in order to assess quality of GEM solution. Initialization
    of nodes is done in the same loop with GEM calculations, even
    though the bulk composition of the system is constant. This is because,
    in general, temperature T and pressure P may change between the nodes,
    hence the chemical speciation must be made consistent by recalculating
    chemical equilibrium at the respective T and P. In real transport
    codes,
    this part - setting initial conditions and composition in all nodes -
    is much more complex. <br>
    <br>
    To set boundary conditions, different chemical system recipes are read
    separately in a<span style="font-family: Helvetica,Arial,sans-serif;"> </span><span
      style="font-family: monospace;">GEM_read_dbr()</span>
    call taking DBR file names from the file list given as the second
    command line argument). Then, after calculation of equilibrium at
    desired T,P, the data is
    copied into mass transport arrays for the node with the respective
    index. In the particular case of this example, there is only one
    boundary condition for the node with index 0 that
    has
    a different composition and will be used by the transport part as a
    constant infinite source of MgCl<sub>2</sub>, moved into other nodes
    (containing calcium carbonate) by mass transport over time steps. <br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span>
    <table style="text-align: left; width: 100%; font-family: monospace;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <br>
            &nbsp;&nbsp;&nbsp; // Initialization of GEMS3K and chemical
            information for nodes kept in the MT part<br>
            &nbsp;&nbsp;&nbsp; long int in;<br>
            &nbsp;&nbsp;&nbsp; for(&nbsp; in=0; in&lt; mt.nNodes; in++ )<br>
            &nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Asking GEM IPM to run
            with automatic initial approximation<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dBR-&gt;NodeStatusCH =
            NEED_GEM_AIA;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) re-calculating
            equilibrium by calling GEMIPM2K, getting the status back<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mt.aNodeStatusCH[in] =
            node-&gt;GEM_run( false);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !(
            mt.aNodeStatusCH[in] == OK_GEM_AIA || mt.aNodeStatusCH[in] ==
            OK_GEM_SIA ) )<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            cout &lt;&lt; "Error occured during re-calculating equilibrium" ;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            return 5;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Extracting GEM IPM
            input data to mass-transport program arrays<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_restore_MT(
            mt.aNodeHandle[in], mt.aNodeStatusCH[in], mt.aT[in], mt.aP[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aVs[in], mt.aMs[in], mt.abIC[in], mt.adul[in], mt.adll[in],
            mt.aaPH[in] );<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Extracting GEM IPM
            output data to mass-transport program arrays<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node-&gt;GEM_to_MT(
            mt.aNodeHandle[in], mt.aNodeStatusCH[in], mt.aIterDone[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aVs[in], mt.aMs[in], mt.aGs[in], mt.aHs[in], mt.aIC[in],
            mt.apH[in], mt.ape[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aEh[in], mt.arMB[in], mt.auIC[in], mt.axDC[in], mt.agam[in],
            mt.axPH[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.avPS[in], mt.amPS[in], mt.abPS[in], mt.axPA[in], mt.aaPh[in],
            mt.abSP[in] );<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here the setup of
            initial differences between node compositions,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;
            temperatures, etc. can be implemented<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here the file output
            for the initial conditions can be implemented<br>
            &nbsp;&nbsp;&nbsp; }<br>
            <br>
            &nbsp;&nbsp;&nbsp; if (argc &gt;= 3 )&nbsp; // Read DATABR structure
            from text file<br>
            &nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char NextRecipeFileName[256];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
            NextRecipeOutFileName[300];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
            input_recipes_file_list_path[256-fileNameLength] = "";<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reading list of recipes
            names from file<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recipes = f_getfiles(&nbsp;
            input_recipes_file_list_name,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            input_recipes_file_list_path, mt.nRecipes, ',');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in this example, nRecipes =
            1 (one additional input recipe)<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(&nbsp; in=0;
            in&lt;min(mt.nRecipes, mt.nNodes); in++ )<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Trying to
            read the next DBR file name<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            sprintf(NextRecipeFileName , "%s%s", input_recipes_file_list_path,
            recipes[in] );<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)
            Reading the next DBR file (boundary condition on the left)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            node-&gt;GEM_read_dbr( NextRecipeFileName );<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Asking GEM
            IPM to run with automatic initial approximation<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            dBR-&gt;NodeStatusCH = NEED_GEM_AIA;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)
            Re-calculating chemical equilibrium by calling GEM<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aNodeStatusCH[in] = node-&gt;GEM_run( false );<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !(
            mt.aNodeStatusCH[in] == OK_GEM_AIA || mt.aNodeStatusCH[in] ==
            OK_GEM_SIA ) )<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            cout &lt;&lt; "Error occured during re-calculating chemical
            equilibrium" ;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            return 5;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)
            Extracting GEMIPM input data to mass-transport program arrays<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            node-&gt;GEM_restore_MT( mt.aNodeHandle[in], mt.aNodeStatusCH[in],
            mt.aT[in], mt.aP[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aVs[in], mt.aMs[in], mt.abIC[in], mt.adul[in], mt.adll[in],
            mt.aaPH[in] );<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)
            Extracting GEMIPM output data to mass-transport program arrays<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            node-&gt;GEM_to_MT( mt.aNodeHandle[in], mt.aNodeStatusCH[in],
            mt.aIterDone[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aVs[in], mt.aMs[in], mt.aGs[in], mt.aHs[in], mt.aIC[in],
            mt.apH[in], mt.ape[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.aEh[in], mt.arMB[in], mt.auIC[in], mt.axDC[in], mt.agam[in],
            mt.axPH[in],<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            mt.avPS[in], mt.amPS[in], mt.abPS[in], mt.axPA[in], mt.aaPh[in],
            mt.abSP[in] );<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here the
            setup of initial differences between node compositions,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            //&nbsp;&nbsp;&nbsp; temperatures, etc. can be implemented<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here the
            file output for the initial conditions can be implemented<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; // end loop on in<br>
            &nbsp;&nbsp;&nbsp; }<br>
            <br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>The last code snippet below shows how the main loop of coupled
      calculations is organized.&nbsp; <br>
      <br>
      Firstly, the use of access methods for extracting indexes of
      independent chemical components and phases is shown. Next, the 'time loop'
      begins with the 'mass transport' as such
      represented as a single<span style="font-family: Helvetica,Arial,sans-serif;">
      </span><span style="font-family: monospace;">mt.OneTimeStepRun()</span>
      function
      call; in principle, in this function, also the temperature of each node
      may
      change. <br>
      <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      </span>After that, the nested 'chemical equilibriation loop' performs
      re-calculation of equilibria in all nodes whose bulk composition had
      just been modified at the 'mass transport' stage at this time step.
      This loop also demonstrates how to use the 'smart initial
      approximation' (SIA) mode of GEM IPM (the code line for the use of AIA -
      automatic initial approximation - is commented out). After some output
      indicating
      changes in chemical speciation at this time step in each node,
      the&nbsp; chemical equilibration loop is closed, and control goes to
      the mass transport time loop. Note that at this stage, various
      back-coupling calculations, i.e. how precipitation/dissolution of some
      phases has affected the porosity and transport properties, can be
      implemented&nbsp; (in a real coupling, of course). <br>
    </p>
    <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><span style="font-family: monospace;">&nbsp;<br>
              &nbsp;&nbsp; // Main loop - iterations over nTimes time steps<br>
              &nbsp;&nbsp;&nbsp; int xCalcite =
              node-&gt;Ph_name_to_xDB("Calcite");<br>
              &nbsp;&nbsp;&nbsp; int xDolomite =
              node-&gt;Ph_name_to_xDB("Dolomite-dis");<br>
              &nbsp;&nbsp;&nbsp; int xAq_gen =
              node-&gt;Ph_name_to_xDB("aq_gen");<br>
              &nbsp;&nbsp;&nbsp; long int ICndx[5];<br>
              &nbsp;&nbsp;&nbsp; ICndx[0] = node-&gt;IC_name_to_xDB("Ca");<br>
              &nbsp;&nbsp;&nbsp; ICndx[1] = node-&gt;IC_name_to_xDB("C");<br>
              &nbsp;&nbsp;&nbsp; ICndx[2] = node-&gt;IC_name_to_xDB("O");<br>
              &nbsp;&nbsp;&nbsp; ICndx[3] = node-&gt;IC_name_to_xDB("Mg");<br>
              &nbsp;&nbsp;&nbsp; ICndx[4] = node-&gt;IC_name_to_xDB("Cl");<br>
              &nbsp;&nbsp;&nbsp; // Checking indexes<br>
              &nbsp;&nbsp;&nbsp; cout &lt;&lt; "xCa= " &lt;&lt; ICndx[0]
              &lt;&lt; " xC=" &lt;&lt; ICndx[1] &lt;&lt; " xO=" &lt;&lt;
              ICndx[2] &lt;&lt; " xMg="<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; ICndx[3]
              &lt;&lt; " xCl=" &lt;&lt; ICndx[4] &lt;&lt; endl &lt;&lt; "
              xCalcite=" &lt;&lt; xCalcite<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "
              xDolomite=" &lt;&lt; xDolomite &lt;&lt; " xAq_gen=" &lt;&lt;
              xAq_gen &lt;&lt; endl &lt;&lt; endl;<br>
              <br>
              &nbsp;&nbsp;&nbsp; time (&amp;start);<br>
              <br>
              &nbsp;&nbsp;&nbsp; long int it;<br>
              &nbsp;&nbsp;&nbsp; for( it=0; it&lt; mt.nTimes; it++ )<br>
              &nbsp;&nbsp;&nbsp; {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Time
              step&nbsp; " &lt;&lt; it;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mass transport loop over
              nodes (not a real transport model)<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mt.OneTimeStepRun( ICndx, 5
              );<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
              "Node\tAq\tpH\tCalcite\tDolomite\tCa\tMg\tCl" &lt;&lt; endl;<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Chemical equilibration
              loop over nodes<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( in=0; in&lt; mt.nNodes;
              in++ )<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aNodeHandle[in] = in;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aNodeStatusCH[in] = NEED_GEM_SIA;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
              mt.aNodeStatusCH[in] = NEED_GEM_AIA;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)
              Setting input data for GEM IPM to use available node speciation as<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initial
              approximation<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              node-&gt;GEM_from_MT( mt.aNodeHandle[in], mt.aNodeStatusCH[in],<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aT[in], mt.aP[in], mt.aVs[in], mt.aMs[in],<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.abIC[in], mt.adul[in], mt.adll[in], mt.aaPH[in], mt.axDC[in],
              mt.agam[in] );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
              (9)&nbsp;&nbsp; Passing current FMT iteration information into the
              work DATABR structure<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              node-&gt;GEM_set_MT( (double)it, 1. );<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Calling
              GEMIPM calculation<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aNodeStatusCH[in] = node-&gt;GEM_run( true );<br>
              <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (
              mt.aNodeStatusCH[in] == ERR_GEM_AIA || mt.aNodeStatusCH[in] ==
              ERR_GEM_SIA ||<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aNodeStatusCH[in] ==&nbsp; T_ERROR_GEM ) )<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              cout &lt;&lt; "Error: GEM calculation results are not retrieved.
              Time step"<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              &lt;&lt; it &lt;&lt; " node " &lt;&lt; in &lt;&lt; endl;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              if( ( mt.aNodeStatusCH[in] == BAD_GEM_AIA || mt.aNodeStatusCH[in]
              == BAD_GEM_SIA&nbsp; ) )<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              {<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              cout &lt;&lt; "Insufficient quality of GEM solution, but GEM
              results are retrieved"<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              &lt;&lt; it &lt;&lt; " node " &lt;&lt; in &lt;&lt; endl;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              else // (7) Extracting GEMIPM output data to FMT part<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              node-&gt;GEM_to_MT( mt.aNodeHandle[in], mt.aNodeStatusCH[in],
              mt.aIterDone[in],<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aVs[in], mt.aMs[in], mt.aGs[in], mt.aHs[in], mt.aIC[in],
              mt.apH[in], mt.ape[in],<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.aEh[in],mt.arMB[in], mt.auIC[in], mt.axDC[in], mt.agam[in],
              mt.axPH[in],<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              mt.avPS[in], mt.amPS[in], mt.abPS[in], mt.axPA[in], mt.aaPh[in],
              mt.abSP[in] );<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Here,
              the output upon completion of the time step is usually implemented<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; to
              monitor the coupled simulation or collect results<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout
              &lt;&lt; in &lt;&lt;"\t"&lt;&lt; mt.axPH[in][xAq_gen] &lt;&lt;
              "\t" &lt;&lt; mt.apH[in] &lt;&lt;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              "\t" &lt;&lt; mt.axPH[in][xCalcite] &lt;&lt;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              "\t" &lt;&lt; mt.axPH[in][xDolomite] &lt;&lt;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              "\t" &lt;&lt; mt.abPS[in][ICndx[0]] &lt;&lt;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              "\t" &lt;&lt; mt.abPS[in][ICndx[3]] &lt;&lt;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              "\t" &lt;&lt; mt.abPS[in][ICndx[4]] &lt;&lt;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              endl;<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
              &nbsp;&nbsp; }<br>
              &nbsp;&nbsp; // Calculations finished - end time reached<br>
              &nbsp;&nbsp;&nbsp; time (&amp;end);<br>
              &nbsp;&nbsp;&nbsp; double dif = difftime (end,start);<br>
              &nbsp;&nbsp;&nbsp; printf ("Elasped time is %.2lf seconds.", dif
              );<br>
              <br>
              &nbsp;&nbsp; // Final output e.g. of total simulation time or of
              the final distribution of<br>
              &nbsp;&nbsp; //&nbsp; components and phases in all nodes can be
              implemented here<br>
              <br>
              &nbsp;&nbsp; // deleting GEM IPM and data exchange memory
              structures<br>
              &nbsp;&nbsp; delete node;<br>
              &nbsp;&nbsp; // end of example<br>
              &nbsp;&nbsp; return 0;<br>
              }<br>
            </span><span style="font-family: monospace;"><br>
            </span></td>
        </tr>
      </tbody>
    </table>
    <br>
    Run this example in SIA or AIA mode and compare the computing time. <br>
    <br>
    <hr size="2" width="100%">
    <h3><a name="TAG_FAQ"></a>4. Frequently asked questions</h3>
    <p>&nbsp;
      &lt;under construction&gt;<br>
    </p>
    <hr size="2" width="100%">
    <p> </p>
    <p>Last change: 31.08.2014 DK<br>
    </p>
    <p>Copyright (c) 2012-2014 <a href="http://gems.web.psi.ch/teamhist.html">GEMS
        Development Team</a></p>
    <p><br>
      &nbsp; </p>
    <br>
    <br>
  </body>
</html>
